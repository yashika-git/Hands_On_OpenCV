# -*- coding: utf-8 -*-
"""Untitled79.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rQqJoWyLPCn4NWP-Jp7-shGAR5T8HZdP
"""

# !pip install opencv-python
import cv2
import argparse
import numpy as np

parser = argparse.ArgumentParser()
parser.add_argument("image", type=str, default="img1.jpg", help="Path of the image")
parser.add_argument("coordinate", type=str, default="0,0", help="Pixel Coordinates")
args = parser.parse_args()

image_path = args.image
img = cv2.imread(image_path)
output = img.copy()
gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

x_coord, y_coord = (args.coordinate.split(','))
x_coord = int(x_coord)
y_coord = int(y_coord)

#Detecting circles through Hough Circles
#cv2.HoughCircles(image, method, dp, minDist, param1, param2, minRadius, maxRadius)
circles= cv2.HoughCircles(gray_img, cv2.HOUGH_GRADIENT, 1, 250, param1=50, param2=15, minRadius=0, maxRadius=0)

if circles is not None:
  for circle in circles:
    circles = np.round(circles[0, :]).astype("int")
    #x,y,r are the centre coordinates and radius of the detected circle respectively
    for (x, y, r) in circles:
      #cv2.circle(image, center_coordinates, radius, color, thickness)
      #Plotting the detected circle
      cv2.circle(output, (x, y), r, (255, 0, 0), 5) 
      #Plotting the coordinate to be judged
      cv2.circle(output, (x_coord, y_coord), radius=2, color=(0,255, 255), thickness=1)
      #Finding the distance between the centre coordinates of the circle and coordinates of the point to be judged
      distance = np.sqrt((x - x_coord)**2 + (y - y_coord)**2)

      #If the calculated distance is greater than the radius of the detected circle, the point lies outside the circle and vice versa
      if distance > r :
            print('Outside')
      else:
            print('Inside')

  cv2.imshow("output_image", output)
  cv2.waitKey(0)
else:
    print("No circular figures are present in the image")

